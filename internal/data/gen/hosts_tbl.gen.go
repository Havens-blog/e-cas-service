// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package gen

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/Havens-blog/e-cas-service/internal/data/model"
)

func newHostsTbl(db *gorm.DB, opts ...gen.DOOption) hostsTbl {
	_hostsTbl := hostsTbl{}

	_hostsTbl.hostsTblDo.UseDB(db, opts...)
	_hostsTbl.hostsTblDo.UseModel(&model.HostsTbl{})

	tableName := _hostsTbl.hostsTblDo.TableName()
	_hostsTbl.ALL = field.NewAsterisk(tableName)
	_hostsTbl.CreatedAt = field.NewTime(tableName, "created_at")
	_hostsTbl.UpdatedAt = field.NewTime(tableName, "updated_at")
	_hostsTbl.UpdateVersion = field.NewInt32(tableName, "update_version")
	_hostsTbl.DeletedAt = field.NewField(tableName, "deleted_at")
	_hostsTbl.Deleted = field.NewBool(tableName, "deleted")
	_hostsTbl.ID = field.NewString(tableName, "id")
	_hostsTbl.Description = field.NewString(tableName, "description")
	_hostsTbl.IsEmulated = field.NewBool(tableName, "is_emulated")
	_hostsTbl.Name = field.NewString(tableName, "name")
	_hostsTbl.DomainID = field.NewString(tableName, "domain_id")
	_hostsTbl.DomainSrc = field.NewString(tableName, "domain_src")
	_hostsTbl.IsPublic = field.NewBool(tableName, "is_public")
	_hostsTbl.PublicScope = field.NewString(tableName, "public_scope")
	_hostsTbl.PublicSrc = field.NewString(tableName, "public_src")
	_hostsTbl.Status = field.NewString(tableName, "status")
	_hostsTbl.Progress = field.NewFloat32(tableName, "progress")
	_hostsTbl.Enabled = field.NewBool(tableName, "enabled")
	_hostsTbl.ExternalID = field.NewString(tableName, "external_id")
	_hostsTbl.ImportedAt = field.NewTime(tableName, "imported_at")
	_hostsTbl.Source = field.NewString(tableName, "source")
	_hostsTbl.ZoneID = field.NewString(tableName, "zone_id")
	_hostsTbl.ManagerID = field.NewString(tableName, "manager_id")
	_hostsTbl.BillingType = field.NewString(tableName, "billing_type")
	_hostsTbl.ExpiredAt = field.NewTime(tableName, "expired_at")
	_hostsTbl.BillingCycle = field.NewString(tableName, "billing_cycle")
	_hostsTbl.AutoRenew = field.NewBool(tableName, "auto_renew")
	_hostsTbl.Hostname = field.NewString(tableName, "hostname")
	_hostsTbl.Rack = field.NewString(tableName, "rack")
	_hostsTbl.Slots = field.NewString(tableName, "slots")
	_hostsTbl.AccessMac = field.NewString(tableName, "access_mac")
	_hostsTbl.AccessIP = field.NewString(tableName, "access_ip")
	_hostsTbl.ManagerURI = field.NewString(tableName, "manager_uri")
	_hostsTbl.SysInfo = field.NewString(tableName, "sys_info")
	_hostsTbl.Sn = field.NewString(tableName, "sn")
	_hostsTbl.CPUCount = field.NewInt32(tableName, "cpu_count")
	_hostsTbl.NodeCount = field.NewInt32(tableName, "node_count")
	_hostsTbl.CPUDesc = field.NewString(tableName, "cpu_desc")
	_hostsTbl.CPUMhz = field.NewInt32(tableName, "cpu_mhz")
	_hostsTbl.CPUCache = field.NewInt32(tableName, "cpu_cache")
	_hostsTbl.CPUReserved = field.NewInt32(tableName, "cpu_reserved")
	_hostsTbl.CPUCmtbound = field.NewFloat32(tableName, "cpu_cmtbound")
	_hostsTbl.CPUMicrocode = field.NewString(tableName, "cpu_microcode")
	_hostsTbl.CPUArchitecture = field.NewString(tableName, "cpu_architecture")
	_hostsTbl.MemSize = field.NewInt32(tableName, "mem_size")
	_hostsTbl.MemReserved = field.NewInt32(tableName, "mem_reserved")
	_hostsTbl.MemCmtbound = field.NewFloat32(tableName, "mem_cmtbound")
	_hostsTbl.PageSizeKb = field.NewInt32(tableName, "page_size_kb")
	_hostsTbl.EnableNumaAllocate = field.NewBool(tableName, "enable_numa_allocate")
	_hostsTbl.StorageSize = field.NewInt64(tableName, "storage_size")
	_hostsTbl.StorageType = field.NewString(tableName, "storage_type")
	_hostsTbl.StorageDriver = field.NewString(tableName, "storage_driver")
	_hostsTbl.StorageInfo = field.NewString(tableName, "storage_info")
	_hostsTbl.IpmiIP = field.NewString(tableName, "ipmi_ip")
	_hostsTbl.IpmiInfo = field.NewString(tableName, "ipmi_info")
	_hostsTbl.HostStatus = field.NewString(tableName, "host_status")
	_hostsTbl.HostType = field.NewString(tableName, "host_type")
	_hostsTbl.Version = field.NewString(tableName, "version")
	_hostsTbl.OvnVersion = field.NewString(tableName, "ovn_version")
	_hostsTbl.IsBaremetal = field.NewBool(tableName, "is_baremetal")
	_hostsTbl.IsMaintenance = field.NewBool(tableName, "is_maintenance")
	_hostsTbl.LastPingAt = field.NewTime(tableName, "last_ping_at")
	_hostsTbl.EnableHealthCheck = field.NewBool(tableName, "enable_health_check")
	_hostsTbl.ResourceType = field.NewString(tableName, "resource_type")
	_hostsTbl.RealExternalID = field.NewString(tableName, "real_external_id")
	_hostsTbl.IsImport = field.NewBool(tableName, "is_import")
	_hostsTbl.EnablePxeBoot = field.NewBool(tableName, "enable_pxe_boot")
	_hostsTbl.UUID = field.NewString(tableName, "uuid")
	_hostsTbl.BootMode = field.NewString(tableName, "boot_mode")
	_hostsTbl.OvnMappedIPAddr = field.NewString(tableName, "ovn_mapped_ip_addr")
	_hostsTbl.UefiInfo = field.NewString(tableName, "uefi_info")

	_hostsTbl.fillFieldMap()

	return _hostsTbl
}

type hostsTbl struct {
	hostsTblDo hostsTblDo

	ALL                field.Asterisk
	CreatedAt          field.Time
	UpdatedAt          field.Time
	UpdateVersion      field.Int32
	DeletedAt          field.Field
	Deleted            field.Bool
	ID                 field.String
	Description        field.String
	IsEmulated         field.Bool
	Name               field.String
	DomainID           field.String
	DomainSrc          field.String
	IsPublic           field.Bool
	PublicScope        field.String
	PublicSrc          field.String
	Status             field.String
	Progress           field.Float32
	Enabled            field.Bool
	ExternalID         field.String
	ImportedAt         field.Time
	Source             field.String
	ZoneID             field.String
	ManagerID          field.String
	BillingType        field.String
	ExpiredAt          field.Time
	BillingCycle       field.String
	AutoRenew          field.Bool
	Hostname           field.String
	Rack               field.String
	Slots              field.String
	AccessMac          field.String
	AccessIP           field.String
	ManagerURI         field.String
	SysInfo            field.String
	Sn                 field.String
	CPUCount           field.Int32
	NodeCount          field.Int32
	CPUDesc            field.String
	CPUMhz             field.Int32
	CPUCache           field.Int32
	CPUReserved        field.Int32
	CPUCmtbound        field.Float32
	CPUMicrocode       field.String
	CPUArchitecture    field.String
	MemSize            field.Int32
	MemReserved        field.Int32
	MemCmtbound        field.Float32
	PageSizeKb         field.Int32
	EnableNumaAllocate field.Bool
	StorageSize        field.Int64
	StorageType        field.String
	StorageDriver      field.String
	StorageInfo        field.String
	IpmiIP             field.String
	IpmiInfo           field.String
	HostStatus         field.String
	HostType           field.String
	Version            field.String
	OvnVersion         field.String
	IsBaremetal        field.Bool
	IsMaintenance      field.Bool
	LastPingAt         field.Time
	EnableHealthCheck  field.Bool
	ResourceType       field.String
	RealExternalID     field.String
	IsImport           field.Bool
	EnablePxeBoot      field.Bool
	UUID               field.String
	BootMode           field.String
	OvnMappedIPAddr    field.String
	UefiInfo           field.String

	fieldMap map[string]field.Expr
}

func (h hostsTbl) Table(newTableName string) *hostsTbl {
	h.hostsTblDo.UseTable(newTableName)
	return h.updateTableName(newTableName)
}

func (h hostsTbl) As(alias string) *hostsTbl {
	h.hostsTblDo.DO = *(h.hostsTblDo.As(alias).(*gen.DO))
	return h.updateTableName(alias)
}

func (h *hostsTbl) updateTableName(table string) *hostsTbl {
	h.ALL = field.NewAsterisk(table)
	h.CreatedAt = field.NewTime(table, "created_at")
	h.UpdatedAt = field.NewTime(table, "updated_at")
	h.UpdateVersion = field.NewInt32(table, "update_version")
	h.DeletedAt = field.NewField(table, "deleted_at")
	h.Deleted = field.NewBool(table, "deleted")
	h.ID = field.NewString(table, "id")
	h.Description = field.NewString(table, "description")
	h.IsEmulated = field.NewBool(table, "is_emulated")
	h.Name = field.NewString(table, "name")
	h.DomainID = field.NewString(table, "domain_id")
	h.DomainSrc = field.NewString(table, "domain_src")
	h.IsPublic = field.NewBool(table, "is_public")
	h.PublicScope = field.NewString(table, "public_scope")
	h.PublicSrc = field.NewString(table, "public_src")
	h.Status = field.NewString(table, "status")
	h.Progress = field.NewFloat32(table, "progress")
	h.Enabled = field.NewBool(table, "enabled")
	h.ExternalID = field.NewString(table, "external_id")
	h.ImportedAt = field.NewTime(table, "imported_at")
	h.Source = field.NewString(table, "source")
	h.ZoneID = field.NewString(table, "zone_id")
	h.ManagerID = field.NewString(table, "manager_id")
	h.BillingType = field.NewString(table, "billing_type")
	h.ExpiredAt = field.NewTime(table, "expired_at")
	h.BillingCycle = field.NewString(table, "billing_cycle")
	h.AutoRenew = field.NewBool(table, "auto_renew")
	h.Hostname = field.NewString(table, "hostname")
	h.Rack = field.NewString(table, "rack")
	h.Slots = field.NewString(table, "slots")
	h.AccessMac = field.NewString(table, "access_mac")
	h.AccessIP = field.NewString(table, "access_ip")
	h.ManagerURI = field.NewString(table, "manager_uri")
	h.SysInfo = field.NewString(table, "sys_info")
	h.Sn = field.NewString(table, "sn")
	h.CPUCount = field.NewInt32(table, "cpu_count")
	h.NodeCount = field.NewInt32(table, "node_count")
	h.CPUDesc = field.NewString(table, "cpu_desc")
	h.CPUMhz = field.NewInt32(table, "cpu_mhz")
	h.CPUCache = field.NewInt32(table, "cpu_cache")
	h.CPUReserved = field.NewInt32(table, "cpu_reserved")
	h.CPUCmtbound = field.NewFloat32(table, "cpu_cmtbound")
	h.CPUMicrocode = field.NewString(table, "cpu_microcode")
	h.CPUArchitecture = field.NewString(table, "cpu_architecture")
	h.MemSize = field.NewInt32(table, "mem_size")
	h.MemReserved = field.NewInt32(table, "mem_reserved")
	h.MemCmtbound = field.NewFloat32(table, "mem_cmtbound")
	h.PageSizeKb = field.NewInt32(table, "page_size_kb")
	h.EnableNumaAllocate = field.NewBool(table, "enable_numa_allocate")
	h.StorageSize = field.NewInt64(table, "storage_size")
	h.StorageType = field.NewString(table, "storage_type")
	h.StorageDriver = field.NewString(table, "storage_driver")
	h.StorageInfo = field.NewString(table, "storage_info")
	h.IpmiIP = field.NewString(table, "ipmi_ip")
	h.IpmiInfo = field.NewString(table, "ipmi_info")
	h.HostStatus = field.NewString(table, "host_status")
	h.HostType = field.NewString(table, "host_type")
	h.Version = field.NewString(table, "version")
	h.OvnVersion = field.NewString(table, "ovn_version")
	h.IsBaremetal = field.NewBool(table, "is_baremetal")
	h.IsMaintenance = field.NewBool(table, "is_maintenance")
	h.LastPingAt = field.NewTime(table, "last_ping_at")
	h.EnableHealthCheck = field.NewBool(table, "enable_health_check")
	h.ResourceType = field.NewString(table, "resource_type")
	h.RealExternalID = field.NewString(table, "real_external_id")
	h.IsImport = field.NewBool(table, "is_import")
	h.EnablePxeBoot = field.NewBool(table, "enable_pxe_boot")
	h.UUID = field.NewString(table, "uuid")
	h.BootMode = field.NewString(table, "boot_mode")
	h.OvnMappedIPAddr = field.NewString(table, "ovn_mapped_ip_addr")
	h.UefiInfo = field.NewString(table, "uefi_info")

	h.fillFieldMap()

	return h
}

func (h *hostsTbl) WithContext(ctx context.Context) *hostsTblDo { return h.hostsTblDo.WithContext(ctx) }

func (h hostsTbl) TableName() string { return h.hostsTblDo.TableName() }

func (h hostsTbl) Alias() string { return h.hostsTblDo.Alias() }

func (h *hostsTbl) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := h.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (h *hostsTbl) fillFieldMap() {
	h.fieldMap = make(map[string]field.Expr, 70)
	h.fieldMap["created_at"] = h.CreatedAt
	h.fieldMap["updated_at"] = h.UpdatedAt
	h.fieldMap["update_version"] = h.UpdateVersion
	h.fieldMap["deleted_at"] = h.DeletedAt
	h.fieldMap["deleted"] = h.Deleted
	h.fieldMap["id"] = h.ID
	h.fieldMap["description"] = h.Description
	h.fieldMap["is_emulated"] = h.IsEmulated
	h.fieldMap["name"] = h.Name
	h.fieldMap["domain_id"] = h.DomainID
	h.fieldMap["domain_src"] = h.DomainSrc
	h.fieldMap["is_public"] = h.IsPublic
	h.fieldMap["public_scope"] = h.PublicScope
	h.fieldMap["public_src"] = h.PublicSrc
	h.fieldMap["status"] = h.Status
	h.fieldMap["progress"] = h.Progress
	h.fieldMap["enabled"] = h.Enabled
	h.fieldMap["external_id"] = h.ExternalID
	h.fieldMap["imported_at"] = h.ImportedAt
	h.fieldMap["source"] = h.Source
	h.fieldMap["zone_id"] = h.ZoneID
	h.fieldMap["manager_id"] = h.ManagerID
	h.fieldMap["billing_type"] = h.BillingType
	h.fieldMap["expired_at"] = h.ExpiredAt
	h.fieldMap["billing_cycle"] = h.BillingCycle
	h.fieldMap["auto_renew"] = h.AutoRenew
	h.fieldMap["hostname"] = h.Hostname
	h.fieldMap["rack"] = h.Rack
	h.fieldMap["slots"] = h.Slots
	h.fieldMap["access_mac"] = h.AccessMac
	h.fieldMap["access_ip"] = h.AccessIP
	h.fieldMap["manager_uri"] = h.ManagerURI
	h.fieldMap["sys_info"] = h.SysInfo
	h.fieldMap["sn"] = h.Sn
	h.fieldMap["cpu_count"] = h.CPUCount
	h.fieldMap["node_count"] = h.NodeCount
	h.fieldMap["cpu_desc"] = h.CPUDesc
	h.fieldMap["cpu_mhz"] = h.CPUMhz
	h.fieldMap["cpu_cache"] = h.CPUCache
	h.fieldMap["cpu_reserved"] = h.CPUReserved
	h.fieldMap["cpu_cmtbound"] = h.CPUCmtbound
	h.fieldMap["cpu_microcode"] = h.CPUMicrocode
	h.fieldMap["cpu_architecture"] = h.CPUArchitecture
	h.fieldMap["mem_size"] = h.MemSize
	h.fieldMap["mem_reserved"] = h.MemReserved
	h.fieldMap["mem_cmtbound"] = h.MemCmtbound
	h.fieldMap["page_size_kb"] = h.PageSizeKb
	h.fieldMap["enable_numa_allocate"] = h.EnableNumaAllocate
	h.fieldMap["storage_size"] = h.StorageSize
	h.fieldMap["storage_type"] = h.StorageType
	h.fieldMap["storage_driver"] = h.StorageDriver
	h.fieldMap["storage_info"] = h.StorageInfo
	h.fieldMap["ipmi_ip"] = h.IpmiIP
	h.fieldMap["ipmi_info"] = h.IpmiInfo
	h.fieldMap["host_status"] = h.HostStatus
	h.fieldMap["host_type"] = h.HostType
	h.fieldMap["version"] = h.Version
	h.fieldMap["ovn_version"] = h.OvnVersion
	h.fieldMap["is_baremetal"] = h.IsBaremetal
	h.fieldMap["is_maintenance"] = h.IsMaintenance
	h.fieldMap["last_ping_at"] = h.LastPingAt
	h.fieldMap["enable_health_check"] = h.EnableHealthCheck
	h.fieldMap["resource_type"] = h.ResourceType
	h.fieldMap["real_external_id"] = h.RealExternalID
	h.fieldMap["is_import"] = h.IsImport
	h.fieldMap["enable_pxe_boot"] = h.EnablePxeBoot
	h.fieldMap["uuid"] = h.UUID
	h.fieldMap["boot_mode"] = h.BootMode
	h.fieldMap["ovn_mapped_ip_addr"] = h.OvnMappedIPAddr
	h.fieldMap["uefi_info"] = h.UefiInfo
}

func (h hostsTbl) clone(db *gorm.DB) hostsTbl {
	h.hostsTblDo.ReplaceConnPool(db.Statement.ConnPool)
	return h
}

func (h hostsTbl) replaceDB(db *gorm.DB) hostsTbl {
	h.hostsTblDo.ReplaceDB(db)
	return h
}

type hostsTblDo struct{ gen.DO }

func (h hostsTblDo) Debug() *hostsTblDo {
	return h.withDO(h.DO.Debug())
}

func (h hostsTblDo) WithContext(ctx context.Context) *hostsTblDo {
	return h.withDO(h.DO.WithContext(ctx))
}

func (h hostsTblDo) ReadDB() *hostsTblDo {
	return h.Clauses(dbresolver.Read)
}

func (h hostsTblDo) WriteDB() *hostsTblDo {
	return h.Clauses(dbresolver.Write)
}

func (h hostsTblDo) Session(config *gorm.Session) *hostsTblDo {
	return h.withDO(h.DO.Session(config))
}

func (h hostsTblDo) Clauses(conds ...clause.Expression) *hostsTblDo {
	return h.withDO(h.DO.Clauses(conds...))
}

func (h hostsTblDo) Returning(value interface{}, columns ...string) *hostsTblDo {
	return h.withDO(h.DO.Returning(value, columns...))
}

func (h hostsTblDo) Not(conds ...gen.Condition) *hostsTblDo {
	return h.withDO(h.DO.Not(conds...))
}

func (h hostsTblDo) Or(conds ...gen.Condition) *hostsTblDo {
	return h.withDO(h.DO.Or(conds...))
}

func (h hostsTblDo) Select(conds ...field.Expr) *hostsTblDo {
	return h.withDO(h.DO.Select(conds...))
}

func (h hostsTblDo) Where(conds ...gen.Condition) *hostsTblDo {
	return h.withDO(h.DO.Where(conds...))
}

func (h hostsTblDo) Exists(subquery interface{ UnderlyingDB() *gorm.DB }) *hostsTblDo {
	return h.Where(field.CompareSubQuery(field.ExistsOp, nil, subquery.UnderlyingDB()))
}

func (h hostsTblDo) Order(conds ...field.Expr) *hostsTblDo {
	return h.withDO(h.DO.Order(conds...))
}

func (h hostsTblDo) Distinct(cols ...field.Expr) *hostsTblDo {
	return h.withDO(h.DO.Distinct(cols...))
}

func (h hostsTblDo) Omit(cols ...field.Expr) *hostsTblDo {
	return h.withDO(h.DO.Omit(cols...))
}

func (h hostsTblDo) Join(table schema.Tabler, on ...field.Expr) *hostsTblDo {
	return h.withDO(h.DO.Join(table, on...))
}

func (h hostsTblDo) LeftJoin(table schema.Tabler, on ...field.Expr) *hostsTblDo {
	return h.withDO(h.DO.LeftJoin(table, on...))
}

func (h hostsTblDo) RightJoin(table schema.Tabler, on ...field.Expr) *hostsTblDo {
	return h.withDO(h.DO.RightJoin(table, on...))
}

func (h hostsTblDo) Group(cols ...field.Expr) *hostsTblDo {
	return h.withDO(h.DO.Group(cols...))
}

func (h hostsTblDo) Having(conds ...gen.Condition) *hostsTblDo {
	return h.withDO(h.DO.Having(conds...))
}

func (h hostsTblDo) Limit(limit int) *hostsTblDo {
	return h.withDO(h.DO.Limit(limit))
}

func (h hostsTblDo) Offset(offset int) *hostsTblDo {
	return h.withDO(h.DO.Offset(offset))
}

func (h hostsTblDo) Scopes(funcs ...func(gen.Dao) gen.Dao) *hostsTblDo {
	return h.withDO(h.DO.Scopes(funcs...))
}

func (h hostsTblDo) Unscoped() *hostsTblDo {
	return h.withDO(h.DO.Unscoped())
}

func (h hostsTblDo) Create(values ...*model.HostsTbl) error {
	if len(values) == 0 {
		return nil
	}
	return h.DO.Create(values)
}

func (h hostsTblDo) CreateInBatches(values []*model.HostsTbl, batchSize int) error {
	return h.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (h hostsTblDo) Save(values ...*model.HostsTbl) error {
	if len(values) == 0 {
		return nil
	}
	return h.DO.Save(values)
}

func (h hostsTblDo) First() (*model.HostsTbl, error) {
	if result, err := h.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.HostsTbl), nil
	}
}

func (h hostsTblDo) Take() (*model.HostsTbl, error) {
	if result, err := h.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.HostsTbl), nil
	}
}

func (h hostsTblDo) Last() (*model.HostsTbl, error) {
	if result, err := h.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.HostsTbl), nil
	}
}

func (h hostsTblDo) Find() ([]*model.HostsTbl, error) {
	result, err := h.DO.Find()
	return result.([]*model.HostsTbl), err
}

func (h hostsTblDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.HostsTbl, err error) {
	buf := make([]*model.HostsTbl, 0, batchSize)
	err = h.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (h hostsTblDo) FindInBatches(result *[]*model.HostsTbl, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return h.DO.FindInBatches(result, batchSize, fc)
}

func (h hostsTblDo) Attrs(attrs ...field.AssignExpr) *hostsTblDo {
	return h.withDO(h.DO.Attrs(attrs...))
}

func (h hostsTblDo) Assign(attrs ...field.AssignExpr) *hostsTblDo {
	return h.withDO(h.DO.Assign(attrs...))
}

func (h hostsTblDo) Joins(fields ...field.RelationField) *hostsTblDo {
	for _, _f := range fields {
		h = *h.withDO(h.DO.Joins(_f))
	}
	return &h
}

func (h hostsTblDo) Preload(fields ...field.RelationField) *hostsTblDo {
	for _, _f := range fields {
		h = *h.withDO(h.DO.Preload(_f))
	}
	return &h
}

func (h hostsTblDo) FirstOrInit() (*model.HostsTbl, error) {
	if result, err := h.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.HostsTbl), nil
	}
}

func (h hostsTblDo) FirstOrCreate() (*model.HostsTbl, error) {
	if result, err := h.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.HostsTbl), nil
	}
}

func (h hostsTblDo) FindByPage(offset int, limit int) (result []*model.HostsTbl, count int64, err error) {
	result, err = h.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = h.Offset(-1).Limit(-1).Count()
	return
}

func (h hostsTblDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = h.Count()
	if err != nil {
		return
	}

	err = h.Offset(offset).Limit(limit).Scan(result)
	return
}

func (h hostsTblDo) Scan(result interface{}) (err error) {
	return h.DO.Scan(result)
}

func (h hostsTblDo) Delete(models ...*model.HostsTbl) (result gen.ResultInfo, err error) {
	return h.DO.Delete(models)
}

func (h *hostsTblDo) withDO(do gen.Dao) *hostsTblDo {
	h.DO = *do.(*gen.DO)
	return h
}
